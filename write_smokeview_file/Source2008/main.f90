PROGRAM FDS  
 
! Fire Dynamics Simulator, Main Program, Single CPU version

USE PRECISION_PARAMETERS
USE MESH_VARIABLES
USE GLOBAL_CONSTANTS
USE TRAN
USE DUMP
USE READ_INPUT
USE INIT
!USE DIVG
!USE PRES
!USE MASS
USE PART
!USE VEGE
!USE VELO
USE RAD
USE MEMORY_FUNCTIONS
USE COMP_FUNCTIONS, ONLY : SECOND, WALL_CLOCK_TIME, SHUTDOWN
USE DEVICE_VARIABLES
USE WALL_ROUTINES
!USE FIRE
USE CONTROL_FUNCTIONS
USE EVAC

IMPLICIT NONE
 
! Miscellaneous declarations

CHARACTER(255), PARAMETER :: mainid='$Id$'
CHARACTER(255), PARAMETER :: mainrev='$Revision$'
CHARACTER(255), PARAMETER :: maindate='$Date$'
LOGICAL  :: EX,DIAGNOSTICS,FIRST_PASS
INTEGER  :: LO10,NM,IZERO,REVISION_NUMBER,IOS
REAL(EB) :: T_MAX,T_MIN
REAL(EB), ALLOCATABLE, DIMENSION(:,:) :: AINV
CHARACTER(255) :: REVISION_DATE
REAL(EB), ALLOCATABLE, DIMENSION(:) :: T,DT_SYNC,DTNEXT_SYNC
INTEGER, ALLOCATABLE, DIMENSION(:) ::  MESH_STOP_STATUS
LOGICAL, ALLOCATABLE, DIMENSION(:) ::  ACTIVE_MESH
INTEGER NOM,IMIN,IMAX,JMIN,JMAX,KMIN,KMAX,IW
INTEGER, PARAMETER :: N_DROP_ADOPT_MAX=10000
TYPE (MESH_TYPE), POINTER :: M,M4
TYPE (OMESH_TYPE), POINTER :: M2,M3

! Start wall clock timing

WALL_CLOCK_START = WALL_CLOCK_TIME()
 
! Assign a compilation date, version number, revision number

WRITE(VERSION_STRING,'(A)') '1.0.0'

IF (INDEX(mainrev,':',BACK=.TRUE.)>0) THEN
   WRITE(REVISION_DATE,'(A)',IOSTAT=IOS,ERR=5) mainrev(INDEX(mainrev,':')+1:LEN_TRIM(mainrev)-2)
   5 REVISION_NUMBER = 0
   IF (IOS==0) READ(REVISION_DATE,'(I5)') REVISION_NUMBER
   WRITE(REVISION_DATE,'(A)') maindate
   !CALL GET_REVISION_NUMBER(REVISION_NUMBER,REVISION_DATE)
   SVN_REVISION_NUMBER = REVISION_NUMBER
   WRITE(COMPILE_DATE,'(A)',IOSTAT=IOS,ERR=10) REVISION_DATE(INDEX(REVISION_DATE,'(')+1:INDEX(REVISION_DATE,')')-1)
   10 IF (IOS>0) COMPILE_DATE = 'null'
ENDIF

! Read input from CHID.data file (All Nodes)

CALL READ_DATA

! Allocate inverse of coarse A matrix and save array for PRESSURE_CORRECTION

IF (PRESSURE_CORRECTION) THEN
   ALLOCATE(AINV(NCGC,NCGC),STAT=IZERO)
   CALL ChkMemErr('MAIN','AINV',IZERO)
   AINV = 0._EB
ENDIF
 
! Open and write to Smokeview file 
 
CALL ASSIGN_FILE_NAMES

CALL EVAC_READ_DATA

CALL WRITE_SMOKEVIEW_FILE
OPEN(LU_SMV,FILE=FN_SMV,FORM='FORMATTED', STATUS='OLD',POSITION='APPEND')

! Write status files
CALL WRITE_STATUS_FILES

! Stop all the processes if this is just a set-up run
IF (SET_UP) CALL SHUTDOWN('Stop FDS, Set-up only')

! Set up Time array (All Nodes)
ALLOCATE(ACTIVE_MESH(NMESHES),STAT=IZERO)
CALL ChkMemErr('MAIN','ACTIVE_MESH',IZERO)
ACTIVE_MESH = .TRUE.
ALLOCATE(T(NMESHES),STAT=IZERO)
CALL ChkMemErr('MAIN','T',IZERO)
ALLOCATE(DT_SYNC(NMESHES),STAT=IZERO)
CALL ChkMemErr('MAIN','DT_SYNC',IZERO)
ALLOCATE(DTNEXT_SYNC(NMESHES),STAT=IZERO)
CALL ChkMemErr('MAIN','DTNEXT_SYNC',IZERO)
ALLOCATE(MESH_STOP_STATUS(NMESHES),STAT=IZERO)
CALL ChkMemErr('MAIN','MESH_STOP_STATUS',IZERO)

T     = T_BEGIN
MESH_STOP_STATUS = NO_STOP
CALL INITIALIZE_GLOBAL_VARIABLES
!IF (RADIATION) CALL INIT_RADIATION
!DO NM=1,NMESHES
!   CALL INITIALIZE_MESH_VARIABLES(NM)
!   IF (PROCESS_STOP_STATUS > 0) CALL END_FDS
!ENDDO

! Allocate and initialize mesh variable exchange arrays

!DO NM=1,NMESHES
!   CALL INITIALIZE_MESH_EXCHANGE(NM)
!ENDDO
!I_MIN = TRANSPOSE(I_MIN)
!I_MAX = TRANSPOSE(I_MAX)
!J_MIN = TRANSPOSE(J_MIN)
!J_MAX = TRANSPOSE(J_MAX)
!K_MIN = TRANSPOSE(K_MIN)
!K_MAX = TRANSPOSE(K_MAX)
!NIC   = TRANSPOSE(NIC)
 
!DO NM=1,NMESHES
!   CALL DOUBLE_CHECK(NM)
!ENDDO

! Initialize Mesh Exchange Arrays (All Nodes)

!CALL MESH_EXCHANGE(0)
 
! Initialize the flow field with random noise to eliminate false symmetries
!IF (NOISE .OR. PERIODIC_TEST) THEN
!   DO NM=1,NMESHES
!     IF (NOISE) CALL INITIAL_NOISE(NM)
!     IF (PERIODIC_TEST) CALL ANALYTICAL_SOLUTION(NM)
!   ENDDO
!   CALL MESH_EXCHANGE(6)
!   PREDICTOR = .FALSE.
!   CORRECTOR = .TRUE.
!   DO NM=1,NMESHES
!      CALL VELOCITY_BC(T_BEGIN,NM)
!   ENDDO
!ENDIF

! Potentially read data from a previous calculation 
!DO NM=1,NMESHES
!   IF (RESTART) CALL READ_RESTART(T(NM),NM)
!ENDDO
 
! Initialize output files containing global data 
!CALL INITIALIZE_GLOBAL_DUMPS
!CALL INIT_EVAC_DUMPS
 
! Initialize output files that are mesh-specific
!DO NM=1,NMESHES
!   CALL INITIALIZE_MESH_DUMPS(NM)
!   CALL INITIALIZE_DROPLETS(NM)
!   CALL INITIALIZE_RAISED_VEG(NM)
!rm  CALL INITIALIZE_TREES(NM)
!   CALL INITIALIZE_EVAC(NM)
!   IF (MESH_STOP_STATUS(NM)/=NO_STOP) PROCESS_STOP_STATUS = MESH_STOP_STATUS(NM)
!ENDDO

!CALL INIT_EVAC_GROUPS

! Write out character strings to .smv file
CALL WRITE_STRINGS

! Initialize Mesh Exchange Arrays (All Nodes)

!!! CALL MESH_EXCHANGE(0)

! Initialize output files 

!IF (.NOT.RESTART) THEN

   ! Make an initial dump of ambient values

   !DO NM=1,NMESHES
   !   CALL UPDATE_GLOBAL_OUTPUTS(T(NM),NM)      
   !   CALL DUMP_MESH_OUTPUTS(T(NM),NM)
   !ENDDO
   !CALL UPDATE_CONTROLS(T)
   !CALL DUMP_GLOBAL_OUTPUTS(T(1))

   ! Check for changes in VENT or OBSTruction control and device status at t=T_BEGIN

   !OBST_VENT_LOOP: DO NM=1,NMESHES
   !   CALL OPEN_AND_CLOSE(T(NM),NM)
   !ENDDO OBST_VENT_LOOP

!ENDIF

IF (PROCESS_STOP_STATUS > 0) CALL END_FDS

WALL_CLOCK_START_ITERATIONS = WALL_CLOCK_TIME()

TUSED(1,1:NMESHES) = SECOND() - TUSED(1,1:NMESHES)
 
CALL TIMINGS

CALL END_FDS
 
CONTAINS


SUBROUTINE END_FDS

SELECT CASE(PROCESS_STOP_STATUS)
   CASE(NO_STOP)
      WRITE(LU_ERR,'(A)') 'STOP: Generate SMV script completed successfully'
      IF (STATUS_FILES) CLOSE(LU_NOTREADY,STATUS='DELETE')
   CASE(USER_STOP)
      WRITE(LU_ERR,'(A)') 'STOP: Program stopped by user'
   CASE(SETUP_STOP)
      WRITE(LU_ERR,'(A)') 'STOP: FDS improperly set-up'
END SELECT

STOP
 
END SUBROUTINE END_FDS


SUBROUTINE DOUBLE_CHECK(NM)
 
! Double check exchange pairs
 
INTEGER NOM
INTEGER, INTENT(IN) :: NM
TYPE (MESH_TYPE), POINTER :: M2,M
 
M=>MESHES(NM)
 
OTHER_MESH_LOOP: DO NOM=1,NMESHES
   IF (NOM==NM .AND. .NOT.PERIODIC_TEST) CYCLE OTHER_MESH_LOOP
   IF (EVACUATION_ONLY(NOM)) CYCLE OTHER_MESH_LOOP ! Issue 257 bug fix
   IF (NIC(NM,NOM)==0 .AND. NIC(NOM,NM)>0) THEN
      M2=>MESHES(NOM)
      ALLOCATE(M%OMESH(NOM)%IJKW(15,M2%NEWC))
      ALLOCATE(M%OMESH(NOM)%BOUNDARY_TYPE(0:M2%NEWC))
      ALLOCATE(M%OMESH(NOM)%WALL(0:M2%NEWC))
   ENDIF
ENDDO OTHER_MESH_LOOP
 
END SUBROUTINE DOUBLE_CHECK

SUBROUTINE WRITE_STRINGS
 
! Write character strings out to the .smv file

INTEGER :: N,NM
 
MESH_LOOP: DO NM=1,NMESHES
   DO N=1,MESHES(NM)%N_STRINGS
      WRITE(LU_SMV,'(A)') TRIM(MESHES(NM)%STRING(N))
   ENDDO
   MESHES(NM)%N_STRINGS = 0
ENDDO MESH_LOOP
 
END SUBROUTINE WRITE_STRINGS

SUBROUTINE EVAC_READ_DATA
IMPLICIT NONE
 
! Read input for EVACUATION routines
 
IF (.Not. ANY(EVACUATION_GRID)) N_EVAC = 0
IF (ANY(EVACUATION_GRID)) CALL READ_EVAC

END SUBROUTINE EVAC_READ_DATA

SUBROUTINE INITIALIZE_EVAC(NM)
IMPLICIT NONE
 
! Initialize evacuation meshes
 
INTEGER, INTENT(IN) :: NM
 
IF (ANY(EVACUATION_GRID)) CALL INITIALIZE_EVACUATION(NM,MESH_STOP_STATUS(NM))
IF (EVACUATION_GRID(NM)) PART_CLOCK(NM) = T_EVAC + DT_PART
IF (EVACUATION_GRID(NM)) CALL DUMP_EVAC(T_EVAC,NM)
IF (ANY(EVACUATION_GRID)) ICYC = -EVAC_TIME_ITERATIONS

END SUBROUTINE INITIALIZE_EVAC

SUBROUTINE INIT_EVAC_DUMPS
IMPLICIT NONE
 
! Initialize evacuation dumps
 
T_EVAC  = - EVAC_DT_FLOWFIELD*EVAC_TIME_ITERATIONS
T_EVAC_SAVE = T_EVAC
IF (ANY(EVACUATION_GRID)) CALL INITIALIZE_EVAC_DUMPS

END SUBROUTINE INIT_EVAC_DUMPS

SUBROUTINE EVAC_CSV(T)
IMPLICIT NONE
REAL(EB), INTENT(IN) :: T
 
! Dump out Evac info
 
IF (T>=EVAC_CLOCK .AND. ANY(EVACUATION_GRID)) THEN
   CALL DUMP_EVAC_CSV(T)
   EVAC_CLOCK = EVAC_CLOCK + DT_HRR
ENDIF

END SUBROUTINE EVAC_CSV

END PROGRAM FDS
